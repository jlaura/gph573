\documentclass[11pt]{article}
\addtolength{\textwidth}{1cm}
\addtolength{\hoffset}{-1cm}
\addtolength{\textheight}{3cm}
\addtolength{\voffset}{-1cm}
\begin{document}

\title{Homework \#4}
\author{Jay Laura}
\date{}
\maketitle

\section{Introduction}
This week's homework required the creation of 10 random points and four rectangles on a cartesian plane with origin (0,0) and bounded at (200,200).  Using three geometries, we were then required to compute whether or not a point was located within one or more of the rectangles .  We were instructed to reuse as much code from previous homeworks as possible.  I have reused the \texttt{Point} class, but not the \texttt{Poly} class from the previous weeks homework.  While I could have subclassed \texttt{Poly}, and added a \texttt{Rectangle} method, I believe it makes more sense to write a simple \texttt{Rectangle} class for now.  I would extend this argument and suggest that writing a series of atomic functions, instead of a class hierarchy, provides the same functionality in a more concise and readable format.  It is also not possible to pass class instances or class attributes to the Python MultiProccesing module, as they are not pickable.  A functional programming architecture provides easier multiprocessing implementation without having to cast class attributes to local scope, pickable, variables.  
 
 \section{Program Architecture}
As described above, this program is designed in a largely functional style.  Two classes exist to reuse previous code, the \texttt{Rectangle} class and \texttt{Point} class.  The program flows as follows.

\begin{enumerate}
\item Randomly generate 10 points using the \texttt{Point} class.  These are attributed with an $x$ and $y$ coordinate.
\item Randomly generate four rectangles.
	\subitem To generate a rectangle the upper left and lower right coordinates are determined.  By definition, the upper right and lower left coordinates can be derived.
\item Use the ray algorithm to compute whether or not a point falls within a rectangle.  This algorithm functions by counting the number of intersections between a rectangles side and a ray (vector) emanating from a point.
	\subitem Note that the determinant method for intersection detection was also implemented, but this method fails to function with line segments.  Lines are extended an infinite distance and therefore interest in all cases except when parallel.
\end{enumerate}

Point in polygon checking is a computationally slow process that could be greatly improved by first computing the bounding box around the vector emanating from the point and checking for intersection.  If the bounding boxes overlap, then the computation could continue to check for the number of times the vector intersects the polygon. 

Finally, the output is written.  This is accomplished using \texttt{.join()} and \texttt{.format} to generate a well formatted output.
\end{document}
